## Python 

* Python basic types / Variables
* Expressions and operators
* Conditionals / flow control
* Loops
* Functions

&nbsp;
&nbsp;
&nbsp;

### Variables

Formally, Python is an interpreted language. Meaning, the interpreter receives the command, evaluates that command, and reports the result of that command. The programmer typically defines a series of commands in advance and saves those commands in a plain text file known as source code. For Python, the source code is conventionally stored in a file named with the .py suffix. On most operating systems, the Python interpreter can be started by typing `python` from the shell/command linе. If you have multiple versions installed `python3` or `python2` depending on the version.

In programming variable is simply a name for something, like "Johnny Depp" is a name for "a human being who wears scarfs". Variables are just containers which store information and data. Start your shell (or the python IDLE whichever you prefer more). If you're in terminal or PowerShell type python and you should see `>>>` meaning you've started the python interpreter. Now enter this.`johnny_depp = "a human being who wears scarfs"` hit enter and type `number_of_scarfs = 100` hit enter. In this case, `johnny_depp` and `number_of_scarfs` are the names of your variables, you've declared them as variables by using `=` syntax. Now type in the variable name and hit enter to see what's contained in it. In all programming languages, there are many different types of variables.

&nbsp;

**The basic types of variables in python.**

Class | Description | Immutable?
------|-------------|----------
`bool`| Boolean value | ✓
`int` | integer (arbitrary magnitude) | ✓
`float` | floating-point number | ✓
`list` | mutable sequence of objects |
`tuple` | immutable sequence of objects | ✓
`str` | character string | ✓
`set` | unordered set of distinct objects |
`frozenset` | immutable form of set class | ✓
`dict` | associative mapping (dictionary) | 

Boolean values can be either `True` or `False`. Integer variables are just whole numbers `number_of_scarfs` was that kind of variable, floats are decimal numbers. String variables are any text information, basic collection of character objects, you declare them in quotation marks, e.g. `johnny_depp` was a string variable. In contrast to many other programming languages, in python, you don't have to know the type of a variable you're creating, you simply declare it with `=` syntax. But it's better you remember the type of the variable you've created. If you type in your shell `type(johnny_depp)` it'll tell you it's a string, and if you type in `type(number_of_scarfs)` it'll tell you it's an integer. If you type in `johnny_depp + number_of_scarfs` it'll give you an error, but if you type in `number_of_scarfs + 1` or `johnny_depp + " while sleeping"` it'll return a result.

Lists, sets, tuples, and dictionaries are some of the basic data structures in python. These are basically ways of storing multiple values behind a single variable. If a python object is immutable it means you can't change it after you've created it, e.g., you can't remove/add new items to a `tuple` but you can remove/add them to a `list` or `dict` etc.. Lists can contain multiple types of variables, including other lists. e.g. (ignore the `>>>` symbol, you don't have to type it in), but type in the rest to get the hang of it.

```python
>>> my_list = [10, 2, 144, 4, 5, 77]
>>> other_list = [1, "apple", 4.56, True]
```

With square bracket notation, you create lists, and you separate values contained in it by a comma. With regular bracket notation e.g. `name_of_tuple = (1, 2, 3, "orange", 3.4)` you create tuples. Each one of the items in a list or a tuple is assigned an index by default. The first item is at index number 0, e.g. 

```python
>>> my_list = [10, 2, 144, 4, 5, 77]
>>> my_list[0]
10
>>>
```
if you request an item that's not on the list, it'll give you an error

```python
>>> my_list[6]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: list index out of range
>>>
```
you can find out the length of a list for example like this
```python
>>> len(my_list)
6
>>>
```
and this way you can find out the last value of a list
```python
>>> my_list[len(my_list) - 1]
77
>>>
```
or you can simply type `my_list[-1]` and it'll go to the last value

Dictionaries are similar to lists, only in dictionaries, you don't access what's contained in it by an index number; each value in a dictionary has a key that you can assign to it. e.g.,

```python
>>> scarfbook_of_depp = {"scarf 1":"blue", "scarf 2":"mahogany", "total":569, "thirsty":True, "drink":"whiskey"}
>>> scarfbook_of_depp
{'scarf 1': 'blue', 'scarf 2': 'mahogany', 'total': 569, 'thirsty': True, 'drink': 'whiskey'}
>>> type(scarfbook_of_depp)
<class 'dict'>
>>>
```

to access a value in a dictionary you use the same notation as with lists, but instead of an index you enter the key, e.g.,

```python
>>> scarfbook_of_depp['scarf 2']
'mahogany'
>>>
```

&nbsp;

### Python expressions and operators in precedence

p |Type | Symbols|
--|-----|-----------------------
1 | member access | `expr.member`
2 | function/method calls | `expr(...)`
2 | cibtauber subscripts/slices | `expr[...]`
3 | exponentation | `**`
4 | unary operators | `+expr, -expr, ~expr`
5 | multiplication, division | `*`, `/`, `//`, `%`
6 | addition, subtraction | `+`, `-`
7 | bitwise shifting | `<<`, `>>`
8 | bitwise-and | ` & `
9 | bitwise-xor | ` ^ `
10 | bitwise-or |  `¦`
11 | comparisons | `is`, `is not`, `==`, `!=`, `<`, `<=`, `>`, `>=`
11 | containment | `in`, `not in`
12 | logical-not | `not expr`
13 | logical-and | `and`
14 | Logical-or | `or`
15 | conditional | `val1 if cond else val2`
16 | assignments | `=`, `+=`, `-=`, `*=`, etc.

To test some of these you can assign values to random variables and try some basic arithmetic e.g. `a = 10` hit enter, then `b = 20`, `c = 30`, then try `a * b`, `a ** b`, `a = b`, `a = b or b < a`, `a < b and b < c` etc.. 

&nbsp;

**Expressions and operators continued**

```python
s[j]  
#element at index j

s[start:stop]  
#slice including indices [start,stop)

s[start:stop:step]  
#slice including indices start, start + step, start + `2*step`,..., up to but not equal or stop

s + t  
#concatenation of sequences

k * s  
#shorthand for s + s + s + ... (k times)

val in s  
#containment check

val not in s 
#non-containment check

d[key]  
#value associated with fiven key

d[key] = value
#set (or reset) the value associated with a given key

del d[key]
#remove key and its associated value from dictionary

key in d
#containment check

key not in d
#non-contaminment check

d1 == d2
#d1 is equivalent to d2

d1 != d2
#d1 is not equivalent to d2
```

&nbsp;

## Conditionals

Conditionals are a way for you to control the flow of the code execution in your script. 

If you're working from the default IDLE go to File > New File. If you're still in your shell, and the python interpreter is open (meaning you still see >>>) type `quit()` to exit the interpreter, and type `atom` to open Atom editor. Save your file with a .py extension (e.g. conditionals.py) then type in this and save it. 

```python
grade = 82

if grade >= 90:
    if grade == 100:
        print('A+')
    else:
        print('A')
        
elif grade >= 80:
    print("B")

elif grade >= 70:
    print("C")
    
else:
    print("F")
```

Note the syntax, whenever you start a conditional you always end it with `:`. Same is true for loops, functions. You've probably noticed that besides autocompleting when you hit enter after a conditional, it also indents for you (it adds white space in front of the next line). This indentation matters in python, it basically tells the interpreter what belongs where. When you're writing code in an editor that doesn't indent automatically, to indent manually, you hit the space four times, not the tab.

Now run your script in the interpreter. If you're using the idle and the default interpreter go Run > Run module. To do this from the shell first navigate to the folder where you've saved your file and type in `python conditionals.py`. It'll execute the script and return `B`. Go back to the editor, change the value of `grade` save it and run it again, do so a few times, or write different other flows to get the hang of it. By the way, in your shell, when you hit upwards arrow key it brings the last command you've typed.

&nbsp;

## Loops

Loops are a way of repeating certain lines of code multiple times.

**While loop**
```python
x = 0
while x < 100:
    print(x)
    x += 1
```
Basically, to read in human language, while x is less than 100 print x and every time you do so add 1 to x. So it makes a list of numbers from 0 to 100 and loops over it. By the way, `x += ` is the same as writing `x = x + 1`. If you didn't add something like this at the end your script would run endlessly because x will always be less than 100, so your computer would crash at the end.

**For loop**
```python
for x in range(10):
    print(x)
```
```python
fruits = ['apple', 'orrange', 'passion fruit']

for fruit in fruits:
    print fruit
````
```python
scarfbook_of_depp = {
"scarf 1":"blue", "scarf 2":"mahogany", "total":569, "thirsty":True, "drink":"whiskey"
}

for key, value in scarfbook_of_depp.items():
    print('% s: % s' % (key, value))
```

&nbsp;

## Functions

Function will take an input, do a certain number of operations within itself, and return a value. You start a function by typing in the `def` key word. For example, this is a basic syntax for functions.

```python
def my_function():
    """Function Documentation"""
    print("Hello World")
```
By the way, anything that's within three quotation marks `""" ... """` or is after the `#` sign is just a comment for us, the interpreter will ignore those lines. These are some examples of functions with arguments.

```python
# Positional
def add(x, y):
    return x + y
    
# keyword
def shout(phrase='Yipee'):
    print(phrase)
    
# Position + Keyword
def echo(text, prefix=''):
    print('%s%s' % (prefix, text)
```
Functions with arbitrary arguments
```python
def some_method(*args, **kwargs):
    for arg in args:
        print arg
    
    for key, value in kwargs.items():
        print key
        
some_method(1, 2, 3, name = 'Numbers')
```


> source
> Goodrich, M., Tamassia, R., & Goldwasser, M. (2013). Data structures and algorithms in Python. Hoboken, NJ: Wiley.
